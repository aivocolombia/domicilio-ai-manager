-- =====================================================
-- CONFIGURACIÓN COMPLETA DE LA BASE DE DATOS DEL MENÚ
-- =====================================================
-- Ejecutar este script en el SQL Editor de Supabase

-- =====================================================
-- 1. CREAR TABLAS
-- =====================================================

-- Tabla platos
CREATE TABLE IF NOT EXISTS platos (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    pricing INTEGER NOT NULL CHECK (pricing >= 0),
    available BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Tabla toppings
CREATE TABLE IF NOT EXISTS toppings (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    pricing INTEGER NOT NULL DEFAULT 0 CHECK (pricing >= 0),
    available BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Tabla bebidas
CREATE TABLE IF NOT EXISTS bebidas (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name TEXT NOT NULL,
    pricing INTEGER NOT NULL CHECK (pricing >= 0),
    available BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    updated_at TIMESTAMP NOT NULL DEFAULT NOW()
);

-- Tabla de relación plato_toppings
CREATE TABLE IF NOT EXISTS plato_toppings (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plato_id BIGINT NOT NULL REFERENCES platos(id) ON DELETE CASCADE,
    "topping_Id" INTEGER NOT NULL REFERENCES toppings(id) ON DELETE RESTRICT,
    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    UNIQUE(plato_id, "topping_Id")
);

-- =====================================================
-- 2. CREAR ÍNDICES
-- =====================================================

-- Índices para optimizar consultas
CREATE INDEX IF NOT EXISTS idx_platos_name ON platos(name);
CREATE INDEX IF NOT EXISTS idx_platos_available ON platos(available);
CREATE INDEX IF NOT EXISTS idx_toppings_name ON toppings(name);
CREATE INDEX IF NOT EXISTS idx_toppings_available ON toppings(available);
CREATE INDEX IF NOT EXISTS idx_bebidas_name ON bebidas(name);
CREATE INDEX IF NOT EXISTS idx_bebidas_available ON bebidas(available);
CREATE INDEX IF NOT EXISTS idx_plato_toppings_plato_id ON plato_toppings(plato_id);
CREATE INDEX IF NOT EXISTS idx_plato_toppings_topping_id ON plato_toppings("topping_Id");

-- =====================================================
-- 3. CREAR FUNCIÓN Y TRIGGERS PARA updated_at
-- =====================================================

-- Función para actualizar updated_at
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = NOW();
    RETURN NEW;
END;
$$ language 'plpgsql';

-- Triggers para actualizar updated_at automáticamente
CREATE TRIGGER update_platos_updated_at 
    BEFORE UPDATE ON platos 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_toppings_updated_at 
    BEFORE UPDATE ON toppings 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_bebidas_updated_at 
    BEFORE UPDATE ON bebidas 
    FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

-- =====================================================
-- 4. CONFIGURAR RLS (ROW LEVEL SECURITY)
-- =====================================================

-- Habilitar RLS en todas las tablas
ALTER TABLE platos ENABLE ROW LEVEL SECURITY;
ALTER TABLE toppings ENABLE ROW LEVEL SECURITY;
ALTER TABLE bebidas ENABLE ROW LEVEL SECURITY;
ALTER TABLE plato_toppings ENABLE ROW LEVEL SECURITY;

-- Políticas para lectura pública (SELECT)
CREATE POLICY "Permitir lectura pública de platos" ON platos
    FOR SELECT USING (true);

CREATE POLICY "Permitir lectura pública de toppings" ON toppings
    FOR SELECT USING (true);

CREATE POLICY "Permitir lectura pública de bebidas" ON bebidas
    FOR SELECT USING (true);

CREATE POLICY "Permitir lectura pública de plato_toppings" ON plato_toppings
    FOR SELECT USING (true);

-- Políticas para escritura solo con service role (INSERT, UPDATE, DELETE)
-- Estas políticas solo permiten acceso con la service role key
CREATE POLICY "Permitir escritura de platos solo con service role" ON platos
    FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Permitir escritura de toppings solo con service role" ON toppings
    FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Permitir escritura de bebidas solo con service role" ON bebidas
    FOR ALL USING (auth.role() = 'service_role');

CREATE POLICY "Permitir escritura de plato_toppings solo con service role" ON plato_toppings
    FOR ALL USING (auth.role() = 'service_role');

-- =====================================================
-- 5. INSERTAR DATOS MÍNIMOS (SEED DATA)
-- =====================================================

-- Insertar platos según especificación
INSERT INTO platos (name, description, pricing, available) VALUES
('Ajiaco', 'Pollo, Mazorca, Arroz, Aguacate, Plátanitos, Alcaparras, Crema de leche', 23000, true),
('Frijol', 'Carne en polvo, Chicharrón, Arroz, Aguacate, Plátanitos', 23000, true)
ON CONFLICT (name) DO NOTHING;

-- Insertar toppings según especificación
INSERT INTO toppings (name, pricing, available) VALUES
('Pollo', 0, true),
('Mazorca', 0, true),
('Arroz', 0, true),
('Aguacate', 0, true),
('Plátanitos', 0, true),
('Alcaparras', 0, true),
('Crema de leche', 0, true),
('Carne en polvo', 0, true),
('Chicharrón', 0, true)
ON CONFLICT (name) DO NOTHING;

-- Insertar bebidas según especificación
INSERT INTO bebidas (name, pricing, available) VALUES
('Limonada sabor a panela', 3300, true),
('Limonada natural', 3000, true),
('Agua', 3300, true),
('Ginger ale', 5500, true),
('Gaseosa', 3500, true),
('Cola y pola', 5000, true)
ON CONFLICT (name) DO NOTHING;

-- Insertar relaciones plato-toppings
-- Ajiaco ↔ [Pollo, Mazorca, Arroz, Aguacate, Plátanitos, Alcaparras, Crema de leche]
INSERT INTO plato_toppings (plato_id, "topping_Id") 
SELECT p.id, t.id
FROM platos p, toppings t
WHERE p.name = 'Ajiaco' 
AND t.name IN ('Pollo', 'Mazorca', 'Arroz', 'Aguacate', 'Plátanitos', 'Alcaparras', 'Crema de leche')
ON CONFLICT (plato_id, "topping_Id") DO NOTHING;

-- Frijol ↔ [Carne en polvo, Chicharrón, Arroz, Aguacate, Plátanitos]
INSERT INTO plato_toppings (plato_id, "topping_Id") 
SELECT p.id, t.id
FROM platos p, toppings t
WHERE p.name = 'Frijol' 
AND t.name IN ('Carne en polvo', 'Chicharrón', 'Arroz', 'Aguacate', 'Plátanitos')
ON CONFLICT (plato_id, "topping_Id") DO NOTHING;

-- =====================================================
-- 6. VERIFICACIÓN Y REPORTE
-- =====================================================

-- Verificar que las tablas se crearon correctamente
SELECT 'Tablas creadas' as info, 
       COUNT(*) as cantidad 
FROM information_schema.tables 
WHERE table_schema = 'public' 
AND table_name IN ('platos', 'toppings', 'bebidas', 'plato_toppings');

-- Verificar datos insertados
SELECT 'platos' as tabla, COUNT(*) as cantidad FROM platos
UNION ALL
SELECT 'toppings' as tabla, COUNT(*) as cantidad FROM toppings
UNION ALL
SELECT 'bebidas' as tabla, COUNT(*) as cantidad FROM bebidas
UNION ALL
SELECT 'plato_toppings' as tabla, COUNT(*) as cantidad FROM plato_toppings;

-- Verificar triggers
SELECT 'Triggers creados' as info,
       COUNT(*) as cantidad
FROM information_schema.triggers 
WHERE trigger_schema = 'public' 
AND trigger_name LIKE '%updated_at%';

-- Verificar políticas RLS
SELECT 'Políticas RLS' as info,
       COUNT(*) as cantidad
FROM pg_policies 
WHERE schemaname = 'public' 
AND tablename IN ('platos', 'toppings', 'bebidas', 'plato_toppings');

-- Mostrar platos con sus toppings (formato esperado por el frontend)
SELECT 
    p.id,
    p.name,
    p.description,
    p.pricing,
    p.available,
    p.created_at,
    p.updated_at,
    COALESCE(
        json_agg(
            json_build_object(
                'id', t.id,
                'name', t.name,
                'pricing', t.pricing,
                'available', t.available,
                'created_at', t.created_at,
                'updated_at', t.updated_at
            ) ORDER BY t.name
        ) FILTER (WHERE t.id IS NOT NULL),
        '[]'
    ) AS toppings
FROM platos p
LEFT JOIN plato_toppings pt ON pt.plato_id = p.id
LEFT JOIN toppings t ON t.id = pt."topping_Id"
WHERE p.available = true
GROUP BY p.id, p.name, p.description, p.pricing, p.available, p.created_at, p.updated_at
ORDER BY p.name;

-- Mostrar bebidas disponibles
SELECT 
    id,
    name,
    pricing,
    available,
    created_at,
    updated_at
FROM bebidas
WHERE available = true
ORDER BY name;

-- =====================================================
-- 7. NOTAS IMPORTANTES
-- =====================================================
/*
NOTAS PARA EL DESARROLLO:

1. RLS está habilitado con políticas que permiten:
   - LECTURA pública (SELECT) para todos los usuarios
   - ESCRITURA solo con service role key

2. Para operaciones de escritura desde el frontend, necesitarás:
   - Usar la service role key en el backend
   - O crear políticas específicas para roles administrativos

3. Los triggers actualizan automáticamente updated_at

4. Las relaciones están configuradas con:
   - CASCADE en platos (borrar plato borra sus toppings)
   - RESTRICT en toppings (no se puede borrar topping en uso)

5. Para deshabilitar RLS temporalmente durante desarrollo:
   ALTER TABLE platos DISABLE ROW LEVEL SECURITY;
   ALTER TABLE toppings DISABLE ROW LEVEL SECURITY;
   ALTER TABLE bebidas DISABLE ROW LEVEL SECURITY;
   ALTER TABLE plato_toppings DISABLE ROW LEVEL SECURITY;
*/ 